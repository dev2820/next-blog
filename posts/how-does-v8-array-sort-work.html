<!DOCTYPE html><html lang="kr" class="__variable_fa65fd __variable_7691e4 scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/next-blog/_next/static/media/3e7b7e3fd4560936-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/next-blog/_next/static/media/ff840cfebfb63b0c-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/40891497?v=4"/><link rel="stylesheet" href="/next-blog/_next/static/css/399f2fb131e5a5c8.css" data-precedence="next"/><link rel="stylesheet" href="/next-blog/_next/static/css/203da25389b4eeab.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/next-blog/_next/static/chunks/webpack-8f27d743501d147d.js"/><script src="/next-blog/_next/static/chunks/f14ca715-03ac7b40665f0731.js" async=""></script><script src="/next-blog/_next/static/chunks/465-9f8ee17d6a70e147.js" async=""></script><script src="/next-blog/_next/static/chunks/main-app-e31317f2a5bf611e.js" async=""></script><script src="/next-blog/_next/static/chunks/805-a8af350d35fb9160.js" async=""></script><script src="/next-blog/_next/static/chunks/app/posts/%5Bslug%5D/layout-1cf1294e1a2539f4.js" async=""></script><script src="/next-blog/_next/static/chunks/618-f2bb34773a0d24b2.js" async=""></script><script src="/next-blog/_next/static/chunks/app/posts/page-e8c6275c8ebfad50.js" async=""></script><script src="/next-blog/_next/static/chunks/952ad60e-f4d0cc7223dc0d92.js" async=""></script><script src="/next-blog/_next/static/chunks/825-5b89faade4363d84.js" async=""></script><script src="/next-blog/_next/static/chunks/349-fa0f205bb3bb240e.js" async=""></script><script src="/next-blog/_next/static/chunks/app/layout-9e366ae8b3d53f7b.js" async=""></script><script src="/next-blog/_next/static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js" async=""></script><link rel="preload" href="https://giscus.app/client.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js" as="script"/><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" as="script"/><title>Terra Dev Blog - V8의 `Array.sort`는 어떻게 동작하는가?</title><link rel="canonical" href="https://dev2820.github.io/next-blog/how-does-v8-array-sort-work"/><meta property="og:title" content="V8의 `Array.sort`는 어떻게 동작하는가?"/><meta property="og:url" content="https://dev2820.github.io/next-blog/how-does-v8-array-sort-work"/><meta property="og:locale" content="ko_KR"/><meta property="og:image" content="https://dev2820.github.io/next-blog/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/><meta property="og:image:width" content="800"/><meta property="og:image:height" content="600"/><meta property="og:image:alt" content="V8의 `Array.sort`는 어떻게 동작하는가?"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="V8의 `Array.sort`는 어떻게 동작하는가?"/><meta name="twitter:image" content="https://dev2820.github.io/next-blog/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/><meta name="twitter:image:width" content="800"/><meta name="twitter:image:height" content="600"/><meta name="twitter:image:alt" content="V8의 `Array.sort`는 어떻게 동작하는가?"/><link rel="icon" href="/next-blog/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/next-blog/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_fa65fd flex flex-col text-gray-800"><link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet"/><header class="flex flex-row justify-center py-2 items-center self-center w-full max-w-screen-md px-4"><a href="/next-blog"><img alt="Terra&#x27;s Devlog logo" loading="lazy" width="258" height="48" decoding="async" data-nimg="1" style="color:transparent" src="/next-blog/_next/static/media/logo-full.a2c57f51.svg"/></a><div class="flex-1"></div><button class="__trds __trds button trds-inline-flex trds-justify-center trds-place-items-center trds-whitespace-nowrap trds-rounded-lg trds-text-md trds-font-medium trds-gap-2 trds-transition-colors trds-cursor-pointer disabled:trds-cursor-not-allowed disabled:trds-opacity-50 trds-bg-transparent trds-text-neutral-500 disabled:trds-bg-transparent enabled:hover:trds-bg-neutral-100 enabled:active:trds-bg-neutral-200 __trds trds-h-10 trds-w-10 trds-px-0 trds-py-0 mr-1 desktop:mr-8" type="button" aria-disabled="false" aria-busy="false" data-scope="dialog" data-part="trigger" dir="ltr" id="dialog::R6ja::trigger" aria-haspopup="dialog" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button class="__trds __trds button trds-inline-flex trds-justify-center trds-place-items-center trds-whitespace-nowrap trds-rounded-lg trds-text-md trds-font-medium trds-gap-2 trds-transition-colors trds-cursor-pointer disabled:trds-cursor-not-allowed disabled:trds-opacity-50 trds-bg-transparent trds-text-neutral-500 disabled:trds-bg-transparent enabled:hover:trds-bg-neutral-100 enabled:active:trds-bg-neutral-200 __trds trds-h-10 trds-w-10 trds-px-0 trds-py-0" type="button" aria-disabled="false" aria-busy="false" data-scope="dialog" data-part="trigger" dir="ltr" id="dialog::R8ja::trigger" aria-haspopup="dialog" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg></button></header><main class="self-center w-full max-w-screen-md p-4 text-gray-800"><article class="relative"><header id="post-meta"><img alt="hero image" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="max-w-full w-full rounded-md" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/><h1 class="mt-10 mb-4 text-heading1 font-bold leading-normal" id="V8의 `Array.sort`는 어떻게 동작하는가?">V8의 `Array.sort`는 어떻게 동작하는가?</h1><time dateTime="2024-04-23" aria-label="Published on 2024-04-23">2024-04-23</time> <!-- -->|<!-- --> <time dateTime="PT4M" aria-label="Estimated reading time">4<!-- --> mins</time></header><div id="content" class="relative"><aside class="absolute -right-12 translate-x-full h-full w-52 desktop:block hidden"><nav class="sticky top-24"><ol><li><a href="#v8은-정렬-이전과-이후에-무엇을-하는가"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-4" data-id="#v8은-정렬-이전과-이후에-무엇을-하는가">V8은 정렬 이전과 이후에 무엇을 하는가</div></a></li><li><a href="#전처리-과정"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#전처리-과정">전처리 과정</div></a></li><li><a href="#후처리-과정"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#후처리-과정">후처리 과정</div></a></li><li><a href="#과거의-정렬-방식-quicksort"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-4" data-id="#과거의-정렬-방식-quicksort">과거의 정렬 방식 (QuickSort)</div></a></li><li><a href="#현재의-정렬-방식-timsort"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-4" data-id="#현재의-정렬-방식-timsort">현재의 정렬 방식 (Timsort)</div></a></li><li><a href="#run이란-무엇인가"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#run이란-무엇인가">run이란 무엇인가?</div></a></li><li><a href="#알고리즘-simple"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#알고리즘-simple">알고리즘 (simple)</div></a></li><li><a href="#minrun의-크기를-결정하는-방식"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#minrun의-크기를-결정하는-방식">minrun의 크기를 결정하는 방식</div></a></li><li><a href="#insertion-sort를-이용하는-이유"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#insertion-sort를-이용하는-이유">Insertion sort를 이용하는 이유</div></a></li><li><a href="#minrun를-기준으로-run-만들기"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#minrun를-기준으로-run-만들기">minrun를 기준으로 run 만들기</div></a></li><li><a href="#run을-병합하기"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#run을-병합하기">run을 병합하기</div></a></li><li><a href="#run-병합-최적화하기---메모리-최적화"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#run-병합-최적화하기---메모리-최적화">run 병합 최적화하기 - 메모리 최적화</div></a></li><li><a href="#run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#run-병합-최적화하기---검사할-필요가-없는-지점-찾기">run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기</div></a></li><li><a href="#run-병합-최적화하기---galloping-모드"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#run-병합-최적화하기---galloping-모드">run 병합 최적화하기 - Galloping 모드</div></a></li><li><a href="#알고리즘-detail"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#알고리즘-detail">알고리즘 (detail)</div></a></li><li><a href="#timsort의-시간복잡도"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-10" data-id="#timsort의-시간복잡도">Timsort의 시간복잡도</div></a></li><li><a href="#v8의-torque"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-4" data-id="#v8의-torque">V8의 Torque</div></a></li><li><a href="#참고"><div class="text-sm font-light data-[active=&quot;true&quot;]:text-base data-[active=&quot;true&quot;]:font-semibold py-0.5 text-neutral-400 data-[active=&quot;true&quot;]:text-primary duration-200 hover:text-primary pl-4" data-id="#참고">참고</div></a></li></ol></nav></aside><section aria-labelledby="v8은-정렬-이전과-이후에-무엇을-하는가"><h2 class="mt-8 mb-3 text-heading2 font-semibold leading-normal" id="v8은-정렬-이전과-이후에-무엇을-하는가"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#v8은-정렬-이전과-이후에-무엇을-하는가"><span class="icon icon-link"></span></a>V8은 정렬 이전과 이후에 무엇을 하는가</h2><p class="font-light leading-normal mt-4 mb-2">V8은 한 개의 전처리 과정과 한 개의 후처리 과정을 거친다. 기본적인 아이디어는 다음과 같다.</p><blockquote class="my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">모든 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code> 값들을 임시 list에 모은 뒤, <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>가 아닌 값들을 정렬하고 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>를 뒤에 붙인다.</p>
</blockquote><section aria-labelledby="전처리-과정"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="전처리-과정"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#전처리-과정"><span class="icon icon-link"></span></a>전처리 과정</h3><p class="font-light leading-normal mt-4 mb-2">먼저 배열의 값들을 다음과 같이 분류한다.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>가 아닌 값들(비교 함수에 따라 정렬될 값)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>값들</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 빈칸, 즉 존재하지 않는 속성들</li>
</ol><p class="font-light leading-normal mt-4 mb-2">실제 정렬 알고리즘은 첫 번째 분류(undefined가 아닌 값)에만 적용되면 된다. 이를 위해서 V8은 다음과 같이 동작하는 전처리 과정을 가진다.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열을 순회하며<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">만약 원소가 hole이다. -&gt; 아무것도 하지 않는다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">만약 원소가 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>이다. -&gt; <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">numberOfUndefineds</code>의 값을 1 증가시킨다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">둘 다 아니라면 원소를 elements라는 임시 배열에 추가한다.</li>
</ol>
</li>
</ol><p class="font-light leading-normal mt-4 mb-2">이 작업이 이루어지면, 모든 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>가 아닌 값들은 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">elements</code>라는 임시 배열에 담기게 된다. <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>들은 개수만 알면 된다. 자바스크립트 sort의 명세에 따르면 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code> 들이 맨 끝에 정렬되어야한다. <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code> 값들은 실제로 유저가 제공한 비교 함수에 전달되지 않을 것이기 때문에 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>가 등장한 횟수만 새면 된다.</p><p class="font-light leading-normal mt-4 mb-2">다음으로 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">elements</code> 배열을 실제로 정렬한다. 글의 후반부 TimSort 섹션에서 자세한 내용을 다룬다.</p></section><section aria-labelledby="후처리-과정"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="후처리-과정"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#후처리-과정"><span class="icon icon-link"></span></a>후처리 과정</h3><p class="font-light leading-normal mt-4 mb-2">전처리를 거치고 얻은 정렬된 값들을 원본 배열 혹은 객체에 덮어써야 한다. 후처리 과정은 다시 세 단계로 구성된다.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">원본 객체의 앞부터 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">elements</code> 배열로 덮어쓴다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">그 뒤를 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">numberOfUndefineds</code> 값만큼 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">undefined</code>로 채운다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">나머지 값들은 삭제한다.</li>
</ol><p class="font-light leading-normal mt-4 mb-2">3번 과정은 정렬하려는 원본 객체에 hole이 포함된 경우에 필요하다. 3번을 하지 않으면 배열에 중복된 값이 생길 수 있다.</p></section></section>
<section aria-labelledby="과거의-정렬-방식-quicksort"><h2 class="mt-8 mb-3 text-heading2 font-semibold leading-normal" id="과거의-정렬-방식-quicksort"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#과거의-정렬-방식-quicksort"><span class="icon icon-link"></span></a>과거의 정렬 방식 (QuickSort)</h2><p class="font-light leading-normal mt-4 mb-2"><code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">Array.prototype.sort</code> 와 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">TypedArray.prototype.sort</code> 는 자바스크립트로 구현된 Quicksort 구현체에 의존했었다. 정렬 알고리즘 다소 단순하다: 기본적으로는 Quicksort를 하지만, 길이가 짧은 배열(length &lt; 10)에 대해서는 삽입 정렬을 사용한다. Quicksort 재귀 중 하위 배열의 길이가 10에 도달하면 삽입 정렬로 대체된다. 작은 배열에 대해서는 삽입 정렬이 더 효율적인데, 이는 Quicksort가 분할 이후 재귀적으로 두 번 호출되기 때문이다. 각 재귀 호출은 스택 프레임을 생성하고(그리고 제거하는) 오버헤드가 있다.</p><p class="font-light leading-normal mt-4 mb-2">Quicksort에서 적절한 pivot을 선택하는 것은 성능에 큰 영향을 준다. V8은 2가지 전략을 채택했다.</p><ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">피봇은 정렬될 배열의 첫 번째, 마지막 그리고 third-element 중 중앙값으로 선택되었다. 작은 배열의 경우 third-element는 단순히 배열의 중간 요소로 선정했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">큰 배열에선 표본을 추출하고, 표본을 정렬한 뒤, 정렬된 표본의 중앙값을 위 계산의 third-element로 사용했다.</li>
</ul><p class="font-light leading-normal mt-4 mb-2">퀵소트의 이점 중 하나는 in-place 정렬을 한다(혹은 그렇게 구현할 수 있다)는 것이다. 메모리 오버헤드는 큰 배열을 정렬할 때 표본을 저장하기 위한 작은 배열 할당과 log(n)의 스택 영역 할당뿐이다. 단점은 안정정렬이 아니라는 점과 QuickSort는 최악의 상황에 O(n^2)의 성능을 보인다는 점이다. 즉, 안정적이지 않았다.</p></section>
<section aria-labelledby="현재의-정렬-방식-timsort"><h2 class="mt-8 mb-3 text-heading2 font-semibold leading-normal" id="현재의-정렬-방식-timsort"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#현재의-정렬-방식-timsort"><span class="icon icon-link"></span></a>현재의 정렬 방식 (Timsort)</h2><p class="font-light leading-normal mt-4 mb-2">2002년 파이썬에 탑재하기 위해 Tim Peter가 개발한 <strong class="font-medium">Timsort</strong>는 Merge sort와 Insertion sort를 기반으로 다양한 최적화 기법을 적용한 정렬이다. 현재는 Python, V8, Swift, Java SE 7 등 다양한 언어에서 채택되었다.</p><p class="font-light leading-normal mt-4 mb-2">기본적인 아이디어는 다음과 같다.</p><blockquote class="my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">연속적으로 정렬된 부분을 &quot;run&quot;이라고 하자.</p>
<p class="font-light leading-normal mt-4 mb-2">대부분의 현실 세계 데이터에는 이미 자연적으로 생긴 run들이 포함되어 있다.
이 run들을 이용하면 비교와 swap 비용을 줄일 수 있다.</p>
<p class="font-light leading-normal mt-4 mb-2">따라서 이 run들을 최대한 활용해 보자!</p>
</blockquote><section aria-labelledby="run이란-무엇인가"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="run이란-무엇인가"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run이란-무엇인가"><span class="icon icon-link"></span></a>run이란 무엇인가?</h3><p class="font-light leading-normal mt-4 mb-2">run은 배열 내에 자연적으로 발생한 연속 정렬된 부분 수열이다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="random_array" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/random_array.jpg"/><em class="[img+&amp;]:block [img+&amp;]:text-center [img+&amp;]:text-gray-400 [img+&amp;]:font-thin [img+&amp;]:not-italic [img+&amp;]:text-sm [img+&amp;]:-translate-y-10">랜덤한 배열</em></p><p class="font-light leading-normal mt-4 mb-2">위와 같이 10개 원소를 가진 배열이 있다고 하자.
<img alt="run_example" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/run_example.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">위의 배열에서 run을 찾으면 (7,4) (9,3) (8,6,2) (10,1) (5)이 있다.</p><p class="font-light leading-normal mt-4 mb-2">run은 마지막 원소가 run이 되는 경우를 제외하고는 항상 길이가 2보다 길다.</p><p class="font-light leading-normal mt-4 mb-2">run은 증가하는 경우와 감소하는 경우 둘 다 상관없다. 배열을 증가하도록 정렬할 때 감소하는 run은 단순히 뒤집기만 하면 증가하는 run으로 만들 수 있기 때문이다.
run을 뒤집을 때는 양 끝값을 서로 swap하며 중앙으로 수렴하는 방식을 이용한다. 이때 stable을 지키기 위해 두 값을 비교해 한쪽이 엄격하게 작은 경우에만 swap한다.</p><pre class="rounded-md [&amp;_code]:py-0 [&amp;_code]:px-0 line-numbers language-js"><code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2 language-js"><span class="code-line">funciton <span class="token function">reverseRun</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> middle <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>middle<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// arr는 어느 방향으로든 정렬이 되어있기 때문에 swap할 두 값의 값이 같다면</span>
</span><span class="code-line">      <span class="token comment">// 더 이상 swap을 할 필요가 없다.</span>
</span><span class="code-line">      <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre></section><section aria-labelledby="알고리즘-simple"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="알고리즘-simple"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#알고리즘-simple"><span class="icon icon-link"></span></a>알고리즘 (simple)</h3><p class="font-light leading-normal mt-4 mb-2">알고리즘의 순서는 다음과 같다.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun의 길이를 결정한다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열을 minrun을 기준으로 잘라 run을 만든다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">run을 병합한다. (1개의 배열이 될 때까지 반복한다)</li>
</ol></section><section aria-labelledby="minrun의-크기를-결정하는-방식"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="minrun의-크기를-결정하는-방식"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#minrun의-크기를-결정하는-방식"><span class="icon icon-link"></span></a>minrun의 크기를 결정하는 방식</h3><p class="font-light leading-normal mt-4 mb-2">run의 크기는 배열의 길이에 따라 유동적으로 결정된다.</p><p class="font-light leading-normal mt-4 mb-2">배열의 원소 수를 N이라고 하자. minrun이 될 수 있는 최대 값을 MAX_MINRUN이라고 하겠다.
N &lt; MAX_MINRUN이라면 minrun값은 N이 된다. 즉, run을 나누지 않는다. 대신 배열을 binary insertion sort한다. 앞서 언급했듯, 작은 배열에선 삽입정렬이 더 효율적이기 때문이다.</p><p class="font-light leading-normal mt-4 mb-2">Merge Sort에선 Merge(병합)해야하는 배열의 수가 2의 거듭제곱 (2^x)일때 가장 효율적이다.
그럴 수 없다면 2의 거듭제곱보다 조금 적을 때 효과적이다. 가장 최악은 2의 거듭제곱보다 조금 더 많은 경우이다.</p><p class="font-light leading-normal mt-4 mb-2">따라서 run의 수가 2의 거듭제곱이 될 수 있게 minrun의 길이를 결정하는 것이 좋다.</p><p class="font-light leading-normal mt-4 mb-2">예를 들어보자, N=2112, run의 길이는 32라고 하자.
run의 개수는 2112/32 = 66개가 나온다.</p><p class="font-light leading-normal mt-4 mb-2">66개의 run들을 병합하는 과정을 보자. 각 병합에는 최악의 경우 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">2 * (run의 길이) - 1</code> 번의 비교가 일어난다. 최악의 경우를 따져보자.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">32길이의 run을 33번 병합해야 한다. 63 * 33번의 비교가 발생했다. (64길이 33개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">64길이의 run을 16번 병합해야 한다. 127 * 16번의 비교가 발생했다. (128길이 16개, 64길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">128길이의 run과 64길이의 run을 병합한다. 128 + 64 - 1번의 비교가 발생했다. (128길이 15개, 192길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">128길이의 run을 7번 병합해야 한다. 255 * 7번의 비교가 발생했다. (256길이 7개, 192길이 1개, 128길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">192길이의 run 1개와 128길이의 run을 병합한다. 192 + 128 - 1번의 비교가 발생했다. (256길이 7개, 320길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">256길이의 run을 3번 병합해야 한다. 511 * 3번의 비교가 발생했다. (512길이 3개, 320길이 1개, 256길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">320길이의 run 1개와 256길이의 run을 병합한다. 320 + 256 - 1번의 비교가 발생했다. (512길이 3개, 576길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">512길이의 run을 1번 병합해야 한다. 1023번의 비교가 발생했다. (1024길이 1개, 576길이 1개, 512길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">576길이의 run 1개와 512길이의 run을 병합한다. 1088번의 비교가 발생했다. (1088길이 1개, 1024길이 1개의 run이 남았다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">1088길이의 run 1개와 1024길이의 run을 병합한다. 2111번의 비교가 발생했다. (병합 완료)</li>
</ol><p class="font-light leading-normal mt-4 mb-2">모두 <strong class="font-medium">12736</strong>번의 비교가 발생한다.</p><p class="font-light leading-normal mt-4 mb-2">하지만 run의 길이가 33이라면 어떨까?
run의 개수는 2112/33 = 64개가 나온다.</p><p class="font-light leading-normal mt-4 mb-2">같은 방식으로 병합을 진행해 보자.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">33길이의 run을 32번 병합해야 한다. 65 * 32번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">66길이의 run을 16번 병합해야 한다. 131 * 16번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">132길이의 run을 8번 병합해야 한다. 263 * 8번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">264길이의 run을 4번 병합해야 한다. 527 * 4번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">528길이의 run을 2번 병합해야 한다. 1055 * 2번의 비교가 발생했다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">1056길이의 run을 1번 병합해야 한다. 2111 * 1번의 비교가 발생했다.</li>
</ol><p class="font-light leading-normal mt-4 mb-2">모두 <strong class="font-medium">12609</strong>번의 비교가 발생한다.</p><p class="font-light leading-normal mt-4 mb-2">즉, run의 길이가 길어지더라도 run의 개수가 2의 거듭제곱과 일치하면 더 적은 비교가 발생한다.
run의 개수가 2의 거듭제곱보다 조금 많을 때 최악의 경우가 발생한다.</p><blockquote class="my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">run의 개수가 2의 거듭제곱과 같다면 효율적이다.
run의 개수가 2의 거듭제곱보다 조금 클 때 비효율적이다.</p>
</blockquote><p class="font-light leading-normal mt-4 mb-2">따라서 N / minrun이 2의 거듭제곱이 되는 minrun을 선택하고, 그런 minrun을 선택할 수 없다면 2의 거듭제곱에 가깝지만 엄격하게 2의 거듭제곱보다 작아지도록 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">MAX_MINRUN / 2 ~ MAX_MINRUN</code> 사이의 값 중에서 minrun을 선택한다.
예를 들어 MAX_MINRUN이 64라면 32 ~ 64중에 minrun을 선택한다.</p><p class="font-light leading-normal mt-4 mb-2">Timsort에선 실제로 MAX_MINRUN을 64로 잡는다. MAX_MINRUN이 8이면 함수 호출이 너무 많아 오버헤드가 더 크고 256이면 binary insertion sort가 느려 마찬가지로 영향을 주는 것을 확인했고, 최종적으로 32를 최적이라 생각했지만, 2112길이의 배열 예시처럼 2의 거듭제곱을 만들 수 있도록 32보다 큰 값을 허용하는 것이 좋다고 판단했기 때문이다.</p></section><section aria-labelledby="insertion-sort를-이용하는-이유"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="insertion-sort를-이용하는-이유"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#insertion-sort를-이용하는-이유"><span class="icon icon-link"></span></a>Insertion sort를 이용하는 이유</h3><p class="font-light leading-normal mt-4 mb-2">Insertion sort(삽입 정렬)는 언뜻 보면 n^2의 시간복잡도를 가져 느리다고 생각할 수 있다. 하지만 앞서 Quicksort에서 설명했듯, 작은 길이 배열에 대해선 2번의 재귀 호출이 일어나는 Merge Sort보다 참조 지역성 원리의 수혜를 아주 잘 누리는 Insertion sort가 더 효율적이다.</p><p class="font-light leading-normal mt-4 mb-2">특히 배열이 이미 어느 정도 정렬되어 있으면 Insertion Sort는 더욱 효과적으로 된다. Insertion Sort는 최선의 경우 O(n)만큼의 복잡도를 갖기 때문이다.</p><p class="font-light leading-normal mt-4 mb-2">여기에 Binary Insertion sort를 사용하면 원소가 삽입될 위치를 O(nlogn)만에 찾도록 더 최적화할 수 있다.</p></section><section aria-labelledby="minrun를-기준으로-run-만들기"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="minrun를-기준으로-run-만들기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#minrun를-기준으로-run-만들기"><span class="icon icon-link"></span></a>minrun를 기준으로 run 만들기</h3><p class="font-light leading-normal mt-4 mb-2">주어진 배열의 길이로부터 minrun을 결정했다. 이제 minrun에 맞춰 배열을 자른다.
앞서 minrun은 32~64 사이의 값을 사용한다고 했지만, 이해를 위해 minrun의 값을 4로 잡자.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 1" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun1.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">먼저 감소하는 부분수열 (7,4)를 찾았다. 하지만 minrun의 길이 4보다 짧기 때문에 뒤의 2개 수를 더 포함해 Binary Insertion Sort를 수행한다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 2" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun2.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">이로써 minrun을 만족하는 첫 번째 run을 만들었다.
다음 run을 만들어보자.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 3" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun3.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">마찬가지로 감소하는 길이 3인 부분 수열 (8,6,2)를 찾았다. 마지막 원소를 추가해 Binary Insertion Sort를 수행한다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 4" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun4.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">2번째로 생성한 run은 minrun 길이는 만족했지만, run은 길수록 좋다. 따라서 뒤에 붙은 원소들을 포함해도 감소/증가하는 부분 수열임을 만족한다면 생성한 run에 추가한다.</p><p class="font-light leading-normal mt-4 mb-2">앞선 run에선 (10)을 포함할 수 없었다. 감소하는 run이었기 때문이다.
이번 run에선 뒤의 원소 (1)을 붙여도 여전히 감소하는 부분 수열을 만족하기 때문에 (1)을 run에 추가한다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 5" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun5.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">마지막 원소는 합칠 수 있는 원소가 더 이상 없기 때문에 그 자체로 run이 된다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="find minrun 6" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun6.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">이렇게 해서 배열은 마지막 run을 제외하고 minrun과 같거나 더 긴 run들로 구성되었다.
이제 이들을 merge하면 된다.</p><p class="font-light leading-normal mt-4 mb-2">여기서 잠깐, 눈치 챘는지 모르겠지만, TimSort는 일반적인 MergeSort와 달리 재귀가 아닌 반복문을 이용해 구현한다. run을 생성하는 과정은 반복문이 이용된다. 이 덕분에 call stack overflow가 발생하지 않는 점도 최적화 포인트이다.</p></section><section aria-labelledby="run을-병합하기"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="run을-병합하기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run을-병합하기"><span class="icon icon-link"></span></a>run을 병합하기</h3><p class="font-light leading-normal mt-4 mb-2">Merge Sort는 병합할 때 비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.</p><p class="font-light leading-normal mt-4 mb-2">길이 m,h인 두 배열을 Merge할 때 최악의 경우 두 배열을 모두 순회하며 비교해야하기 때문에 m+h-1 만큼의 비용이 든다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="merge compare" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/merge_compare.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">5개의 원소를 병합하는 과정을 거칠 때를 예로 들어 보자. 앞의 배열부터 순서대로 병합을 진행한다고 하자. 이렇게 되면 큰 배열과 작은 배열을 연속적으로 병합하는 형태가 될 것이다.
이때 5개의 원소를 모두 병합하는데 들어가는 비용은 1 + 2 + 3 + 4 = 10이다.</p><p class="font-light leading-normal mt-4 mb-2">반면 작은 길이 배열을 먼저 병합하는 경우 모든 원소를 병합하는 비용은 1 + 1 + 2 + 4 = 8이다.</p><blockquote class="my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [&amp;_*:first-child]:mt-0 [&amp;_*:last-child]:mb-0">
<p class="font-light leading-normal mt-4 mb-2">비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.</p>
</blockquote><p class="font-light leading-normal mt-4 mb-2">따라서 Timsort도 비슷한 길이의 배열을 merge할 수 있도록 다음의 방식으로 run들을 병합한다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="merge_criteria" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/merge_criteria.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">run을 생성할 때마다 Stack에 추가한다.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">스택의 상위 3개 run을 확인한다. 각각 A, B, C라고 하겠다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">각 run의 길이는 |A|,|B|,|C|라고 하겠다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">다음의 조건을 만족하지 않으면 B를 A와 C 중 짧은 쪽과 병합한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">|B|가 |A|보다 길다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">|C|가 |A| + |B| 보다 길다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">조건을 만족할 때까지 2를 반복한다.</li>
</ol><p class="font-light leading-normal mt-4 mb-2">이렇게 하면 결과적으로 다음과 같은 Stack을 얻을 수 있다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="fibonacci runstack" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg"/></p><ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">A + B &lt; C</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">B + C &lt; D</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">C + D &lt; E</li>
</ul><p class="font-light leading-normal mt-4 mb-2">이 스택은 마치 피보나치의 수처럼 생겼다.</p><p class="font-light leading-normal mt-4 mb-2">이 스택을 위에서부터 순서대로 병합을 하면 비슷한 길이의 run들을 병합할 수 있다.
또한 스택에 원소들을 적게 유지할 수 있다. 피보나치의 수를 1부터 38까지 전부 더하면 1억을 좀 넘는 값이 나온다. 즉, 이러한 형태의 스택은 1억 개가 넘는 원소를 스택에 38개의 원소로 담고 있을 수 있다.</p></section><section aria-labelledby="run-병합-최적화하기---메모리-최적화"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---메모리-최적화"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---메모리-최적화"><span class="icon icon-link"></span></a>run 병합 최적화하기 - 메모리 최적화</h3><p class="font-light leading-normal mt-4 mb-2">길이가 m,h인 두 run M,H를 병합할 때 우리는 (m+h)*2만큼의 메모리가 필요하다는 것을 알고 있다.
하지만 실은 간단한 최적화를 통해 2m + h (m &lt; h)만큼의 메모리를 사용하도록 개선할 수 있다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">위와 같은 run H와 M이 있다고 하자. (m &lt; h)</p><p class="font-light leading-normal mt-4 mb-2">H 앞에 M을 복사해 붙여 넣는다.</p><p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization 2" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization2.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">이제 M의 시작 지점을 i, H의 시작 지점을 j로 두고 각 i와 j를 증가시키며 M의 복사본 + H 배열에 덮어쓰는 식으로 merge를 수행하면 된다.
i와 j 이전 인덱스는 확인할 필요가 없기 때문에 이러한 전략이 가능하다.</p></section><section aria-labelledby="run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---검사할-필요가-없는-지점-찾기"><span class="icon icon-link"></span></a>run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기</h3><p class="font-light leading-normal mt-4 mb-2"><img alt="merge optimization 3" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization3.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">M의 최댓값(즉 M의 마지막 원소)과 최솟값(M의 첫 번째 원소)가 H안의 어디에 위치하는지 확인하면 그 이후는 병합을 수행하지 않아도 된다.
위 이미지에서 M의 최댓값은 6이며 H[3] = 7보다 작다. 따라서 j가 k(=3)위치에 도착했다면 M[i] ~ M[M.length-1]까지의 값과 H[j] ~ H[H.length-1]값은 비교 없이 배열에 추가해 주면 된다.</p><p class="font-light leading-normal mt-4 mb-2">M의 최댓값, 최솟값이 H 안에서 어디 위치하는지는 Binary Search로 찾으면 된다.</p></section><section aria-labelledby="run-병합-최적화하기---galloping-모드"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="run-병합-최적화하기---galloping-모드"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#run-병합-최적화하기---galloping-모드"><span class="icon icon-link"></span></a>run 병합 최적화하기 - Galloping 모드</h3><p class="font-light leading-normal mt-4 mb-2"><img alt="galloping1" loading="lazy" width="0" height="0" decoding="async" data-nimg="1" class="object-cover rounded-md mx-auto my-12 w-full max-w-[704px]" style="color:transparent" src="/next-blog/posts/how-does-v8-array-sort-work/images/galloping1.jpg"/></p><p class="font-light leading-normal mt-4 mb-2">앞선 예시에서 H를 좀 더 확장해 j와 k 사이에 많은 원소들이 있다고 치자. M[i] 원소를 삽입하기 전까지 H[j]에서부터 6을 발견할 때까지 j와 k 사이를 순회해야한다.
&quot;1개씩 모두 순회하지 않고 중간중간을 생략해 보자!&quot;가 Galloping의 아이디어이다.</p><p class="font-light leading-normal mt-4 mb-2">비교할 위치를 2^n씩 건너뛰며 검사한다. 예를 들어 처음 H[1]과 M[1]을 비교했다면 그 다음은 H[2], H[4], H[8]... 형식으로 비교할 index를 증가시킨다.
만약 H[8]과 비교해도 M[1]이 더 크다면 H[1] ~ H[8]은 M[1]보다 작은 값이니 H[1] ~ H[8]을 비교없이 merge하면 된다. 만약 M[1]이 H[16]보다 작다면 다시 H[8]로 돌아가 index를 1씩 증가시키며 원소를 비교한다.</p><p class="font-light leading-normal mt-4 mb-2">Galloping은 꽤 효율적으로 보이지만, Galloping이 비효율적인 구간도 있다.
일반적으로 H[0] ~ H[i]까지의 값이 M[0]보다 작을 때 선형적으로 i를 찾게되면 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">i+1</code>번의 비교가 발생하지만, Galloping을 이용하면 <code class="rounded-md bg-gray-200 text-red-400 py-0.5 px-2">2 * floor(log(i)) + 2</code> 번의 비교가 필요하다.</p><p class="font-light leading-normal mt-4 mb-2">따라서 i가 6보다 크거나 같아지는 순간부터 Galloping이 효율적이게 된다. 따라서 선형 비교를 할지 Galloping을 할지 적절한 전략을 세우는 것이 필요하다. (선형비교가 3번 이상 일어나면 Galloping모드로 치환하는 등)</p></section><section aria-labelledby="알고리즘-detail"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="알고리즘-detail"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#알고리즘-detail"><span class="icon icon-link"></span></a>알고리즘 (detail)</h3><p class="font-light leading-normal mt-4 mb-2">다시 알고리즘을 세분화하여 다시 작성해 보자.</p><ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun을 찾는다. (<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">listsort.txt</a>의 313줄 참고)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">배열의 앞부분부터 run을 생성한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">minrun만큼 잘라 binary insertion sort를 수행한다. (처음 두 원소가 증가하는 방향이면 increase 정렬을, 감소하는 방향이면 decrease정렬을 수행한다)</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">그 뒤에 오는 원소들을 run에 합쳐도 증가/감소하는 방향을 유지할 수 있다면 run에 붙인다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">생성한 run을 stack에 추가한다.<!-- -->
<ol class="list-decimal my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">stack의 길이가 3보다 크다면, 스택 상위 3개의 원소(A,B,C)를 다음 조건에 맞는지 확인한다.</li>
</ol>
<ul class="list-disc my-4">
<li class="text-paragraph font-light leading-normal py-1 ml-6">|B| &gt; |A|</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">[C| &gt; |A| + |B|</li>
</ul>
<ol class="list-decimal my-4" start="2">
<li class="text-paragraph font-light leading-normal py-1 ml-6">조건에 부합하지 않으면 B를 A와 C중 작은 쪽과 병합(merge)한다. 이를 조건에 부합할 때까지 반복한다.</li>
</ol>
</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">2번으로 돌아가 다음 run을 생성한다.</li>
<li class="text-paragraph font-light leading-normal py-1 ml-6">모든 run 생성을 마치고 Stack에 run이 모두 채워졌다면 스택의 맨 위 원소부터 병합을 수행한다.</li>
</ol></section><section aria-labelledby="timsort의-시간복잡도"><h3 class="mt-7 mb-2 text-heading3 font-semibold leading-normal" id="timsort의-시간복잡도"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#timsort의-시간복잡도"><span class="icon icon-link"></span></a>Timsort의 시간복잡도</h3><p class="font-light leading-normal mt-4 mb-2">Insertion Sort의 최선 시간복잡도는 O(n), run을 생성한 결과 run이 1개만 나온 경우 (즉, 이미 정렬된 경우) O(n)의 시간복잡도를 가진다.
따라서 Timsort의 최선 시간복잡도는 O(n)이다.</p><p class="font-light leading-normal mt-4 mb-2">나머지는 사실상 Merge Sort가 진행되는 것과 같기 때문에 최악 시간복잡도와 평균 시간복잡도는 O(nlogn)이다.</p></section></section>
<section aria-labelledby="v8의-torque"><h2 class="mt-8 mb-3 text-heading2 font-semibold leading-normal" id="v8의-torque"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#v8의-torque"><span class="icon icon-link"></span></a>V8의 Torque</h2><p class="font-light leading-normal mt-4 mb-2">이 부분은 간단하게만 언급하려고 한다. V8은 Torque라는 V8용 언어를 지원하며, 이 언어를 통해 V8의 JIT 수행에서 미리 컴파일 된 코드를 제공하도록 만들 수 있다.
V8은 Torque로 기존 js로 작성된 Array#sort를 다시 작성했으며, 이를 통해 속도를 더욱 끌어올렸다. 구체적인 설명은 <a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://v8.dev/blog/array-sort#introducing-v8-torque">Introducing V8 Torque</a>를 참고하면 된다.</p></section>
<section aria-labelledby="참고"><h2 class="mt-8 mb-3 text-heading2 font-semibold leading-normal" id="참고"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" aria-hidden="true" tabindex="-1" href="#참고"><span class="icon icon-link"></span></a>참고</h2><p class="font-light leading-normal mt-4 mb-2"><a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://v8.dev/blog/array-sort">V8 Blog - array-sort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://en.wikipedia.org/wiki/Timsort">위키피디아 - Timsort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">cpython - Timsort</a>
<a class="__trds trds-inline-flex trds-items-center trds-justify-start trds-whitespace-nowrap trds-gap-1 trds-transition-colors trds-cursor-pointer trds-underline-offset-4 trds-underline-under trds-decoration-[2px] trds-font-bold hover:trds-underline trds-text-primary-500 active:trds-text-primary-800 visited:trds-text-primary-800 hover:trds-text-primary-700 font-medium" type="link" href="https://d2.naver.com/helloworld/0315536">D2 - Timsort에 대해 알아보자</a></p></section><button class="__trds __trds button trds-inline-flex trds-justify-center trds-place-items-center trds-whitespace-nowrap trds-rounded-lg trds-text-md trds-font-medium trds-gap-2 trds-transition-colors trds-cursor-pointer disabled:trds-cursor-not-allowed disabled:trds-opacity-50 trds-bg-neutral trds-text-fg-neutral disabled:trds-bg-neutral enabled:hover:trds-bg-neutral-hover enabled:active:trds-bg-neutral-pressed __trds trds-h-11 trds-w-11 trds-px-0 trds-py-0" type="button" aria-disabled="false" aria-busy="false" aria-label="Share this article"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" x2="12" y1="2" y2="15"></line></svg></button><div data-scope="toast" data-part="group" dir="ltr" tabindex="-1" aria-label="bottom Notifications alt+T" id="toast-group:bottom" data-placement="bottom" data-side="bottom" data-align="center" aria-live="polite" role="region" style="position:fixed;pointer-events:none;display:flex;flex-direction:column;--gap:16px;--first-height:0px;z-index:2147483647;align-items:center;bottom:max(env(safe-area-inset-bottom, 0px), 1rem);inset-inline-end:calc(env(safe-area-inset-right, 0px) + 1rem);inset-inline-start:calc(env(safe-area-inset-left, 0px) + 1rem)"></div></div><section id="author"><div class="flex flex-row gap-4 items-center"><div data-scope="avatar" data-part="root" dir="ltr" id="avatar::Rn7obtsra:" class="trds-rounded-full trds-overflow-hidden w-16 h-16"><img data-scope="avatar" data-part="image" hidden="" dir="ltr" id="avatar::Rn7obtsra::image" data-state="hidden" src="https://avatars.githubusercontent.com/u/40891497?v=4" class="trds-bg-muted"/><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-user trds-bg-muted trds-w-full trds-h-full" data-scope="avatar" data-part="fallback" dir="ltr" id="avatar::Rn7obtsra::fallback" data-state="visible"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg></div><div class="text-pretty flex flex-col gap-2"><strong class="inline-block h-6 min-w-36">dev2820<!-- --> <span>(<!-- -->Terra<!-- -->)</span></strong><p class="whitespace-pre-wrap h-6 min-w-64">FE Developer</p></div></div></section><section id="comments-and-reaction"><div class="giscus w-full"></div></section></article></main><footer class="self-center w-full max-w-screen-md px-4 h-96"><p>© 2024-<!-- -->2024<!-- --> <!-- -->dev2820<!-- -->. All rights reserved.</p></footer><script src="/next-blog/_next/static/chunks/webpack-8f27d743501d147d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/next-blog/_next/static/media/3e7b7e3fd4560936-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/next-blog/_next/static/media/ff840cfebfb63b0c-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/next-blog/_next/static/css/399f2fb131e5a5c8.css\",\"style\"]\n4:HL[\"/next-blog/_next/static/css/203da25389b4eeab.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"5:I[5726,[],\"\"]\n8:I[1699,[],\"\"]\na:I[2579,[],\"\"]\nb:I[3805,[\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"418\",\"static/chunks/app/posts/%5Bslug%5D/layout-1cf1294e1a2539f4.js\"],\"\"]\nc:I[9618,[\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"991\",\"static/chunks/app/posts/page-e8c6275c8ebfad50.js\"],\"\"]\nd:I[2724,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"349\",\"static/chunks/349-fa0f205bb3bb240e.js\",\"185\",\"static/chunks/app/layout-9e366ae8b3d53f7b.js\"],\"BrandLogo\"]\ne:I[8552,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"349\",\"static/chunks/349-fa0f205bb3bb240e.js\",\"185\",\"static/chunks/app/layout-9e366ae8b3d53f7b.js\"],\"GlobalNavigationBar\"]\nf:I[302,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"349\",\"static/chunks/349-fa0f205bb3bb240e.js\",\"185\",\"static/chunks/app/layout-9e366ae8b3d53f7b.js\"],\"SearchButton\"]\n11:I[3141,[],\"\"]\n9:[\"slug\",\"how-does-v8-array-sort-work\",\"d\"]\n12:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/next-blog/_next/static/css/399f2fb131e5a5c8.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"M9enpQaOJD6YYnh6lpLUo\",\"assetPrefix\":\"/next-blog\",\"initialCanonicalUrl\":\"/posts/how-does-v8-array-sort-work\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"how-does-v8-array-sort-work\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"how-does-v8-array-sort-work\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"how-does-v8-array-sort-work\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L6\",\"$L7\"],null],null]},[[[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js\"}],[\"$\",\"$Lb\",null,{\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js\"}]],null],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/next-blog/_next/static/css/203da25389b4eeab.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[[\"$\",\"html\",null,{\"lang\":\"kr\",\"className\":\"__variable_fa65fd __variable_7691e4 scroll-smooth\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_fa65fd flex flex-col text-gray-800\",\"children\":[[\"$\",\"link\",null,{\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css\",\"rel\":\"stylesheet\"}],[\"$\",\"header\",null,{\"className\":\"flex flex-row justify-center py-2 items-center self-center w-full max-w-screen-md px-4\",\"children\":[[\"$\",\"$Lc\",null,{\"href\":\"/\",\"children\":[\"$\",\"$Ld\",null,{\"height\":48}]}],[\"$\",\"div\",null,{\"className\":\"flex-1\"}],[\"$\",\"$Le\",null,{\"className\":\"mr-1 desktop:mr-8\"}],[\"$\",\"$Lf\",null,{}]]}],[\"$\",\"main\",null,{\"className\":\"self-center w-full max-w-screen-md p-4 text-gray-800\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"h2\",null,{\"children\":\"Not Found\"}],[\"$\",\"p\",null,{\"children\":\"Could not find requested resource\"}],[\"$\",\"$Lc\",null,{\"href\":\"/\",\"children\":\"Return Home\"}]]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"self-center w-full max-w-screen-md px-4 h-96\",\"children\":[\"$\",\"p\",null,{\"children\":[\"© 2024-\",2024,\" \",\"dev2820\",\". All rights reserved.\"]}]}]]}]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L10\"],\"globalErrorComponent\":\"$11\",\"missingSlots\":\"$W12\"}]]\n"])</script><script>self.__next_f.push([1,"13:I[5969,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js\"],\"Image\"]\n14:I[2870,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js\"],\"TableOfContents\"]\n15:I[6894,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js\"],\"Anchor\"]\n16:I[1232,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js\"],\"ShareButton\"]\n17:I[4201,[\"587\",\"static/chunks/952ad60e-f4d0cc7223dc0d92.js\",\"618\",\"static/chunks/618-f2bb34773a0d24b2.js\",\"825\",\"static/chunks/825-5b89faade4363d84.js\",\"805\",\"static/chunks/805-a8af350d35fb9160.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-9f5d24ca90f99f34.js\"],\"AuthorInfo\"]\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"article\",null,{\"className\":\"relative\",\"children\":[[\"$\",\"header\",null,{\"id\":\"post-meta\",\"children\":[[\"$\",\"$L13\",null,{\"alt\":\"hero image\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\",\"className\":\"max-w-full w-full rounded-md\",\"width\":0,\"height\":0}],[\"$\",\"h1\",null,{\"className\":\"mt-10 mb-4 text-heading1 font-bold leading-normal\",\"id\":\"V8의 `Array.sort`는 어떻게 동작하는가?\",\"children\":\"V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-23\",\"aria-label\":\"Published on 2024-04-23\",\"children\":\"2024-04-23\"}],\" \",\"|\",\" \",[\"$\",\"time\",null,{\"dateTime\":\"PT4M\",\"aria-label\":\"Estimated reading time\",\"children\":[4,\" mins\"]}]]}],[\"$\",\"div\",null,{\"id\":\"content\",\"className\":\"relative\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"absolute -right-12 translate-x-full h-full w-52 desktop:block hidden\",\"children\":[\"$\",\"$L14\",null,{\"toc\":[{\"level\":2,\"content\":\"V8은 정렬 이전과 이후에 무엇을 하는가\",\"slug\":\"#v8은-정렬-이전과-이후에-무엇을-하는가\"},{\"level\":3,\"content\":\"전처리 과정\",\"slug\":\"#전처리-과정\"},{\"level\":3,\"content\":\"후처리 과정\",\"slug\":\"#후처리-과정\"},{\"level\":2,\"content\":\"과거의 정렬 방식 (QuickSort)\",\"slug\":\"#과거의-정렬-방식-quicksort\"},{\"level\":2,\"content\":\"현재의 정렬 방식 (Timsort)\",\"slug\":\"#현재의-정렬-방식-timsort\"},{\"level\":3,\"content\":\"run이란 무엇인가?\",\"slug\":\"#run이란-무엇인가\"},{\"level\":3,\"content\":\"알고리즘 (simple)\",\"slug\":\"#알고리즘-simple\"},{\"level\":3,\"content\":\"minrun의 크기를 결정하는 방식\",\"slug\":\"#minrun의-크기를-결정하는-방식\"},{\"level\":3,\"content\":\"Insertion sort를 이용하는 이유\",\"slug\":\"#insertion-sort를-이용하는-이유\"},{\"level\":3,\"content\":\"minrun를 기준으로 run 만들기\",\"slug\":\"#minrun를-기준으로-run-만들기\"},{\"level\":3,\"content\":\"run을 병합하기\",\"slug\":\"#run을-병합하기\"},{\"level\":3,\"content\":\"run 병합 최적화하기 - 메모리 최적화\",\"slug\":\"#run-병합-최적화하기---메모리-최적화\"},{\"level\":3,\"content\":\"run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기\",\"slug\":\"#run-병합-최적화하기---검사할-필요가-없는-지점-찾기\"},{\"level\":3,\"content\":\"run 병합 최적화하기 - Galloping 모드\",\"slug\":\"#run-병합-최적화하기---galloping-모드\"},{\"level\":3,\"content\":\"알고리즘 (detail)\",\"slug\":\"#알고리즘-detail\"},{\"level\":3,\"content\":\"Timsort의 시간복잡도\",\"slug\":\"#timsort의-시간복잡도\"},{\"level\":2,\"content\":\"V8의 Torque\",\"slug\":\"#v8의-torque\"},{\"level\":2,\"content\":\"참고\",\"slug\":\"#참고\"}],\"className\":\"sticky top-24\"}]}],[[\"$\",\"section\",null,{\"aria-labelledby\":\"v8은-정렬-이전과-이후에-무엇을-하는가\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"mt-8 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"v8은-정렬-이전과-이후에-무엇을-하는가\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#v8은-정렬-이전과-이후에-무엇을-하는가\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"V8은 정렬 이전과 이후에 무엇을 하는가\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"V8은 한 개의 전처리 과정과 한 개의 후처리 과정을 거친다. 기본적인 아이디어는 다음과 같다.\"}],[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\" 값들을 임시 list에 모은 뒤, \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"가 아닌 값들을 정렬하고 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"를 뒤에 붙인다.\"]}],\"\\n\"]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"전처리-과정\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"전처리-과정\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#전처리-과정\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"전처리 과정\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"먼저 배열의 값들을 다음과 같이 분류한다.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"가 아닌 값들(비교 함수에 따라 정렬될 값)\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"모든 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"값들\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"모든 빈칸, 즉 존재하지 않는 속성들\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"실제 정렬 알고리즘은 첫 번째 분류(undefined가 아닌 값)에만 적용되면 된다. 이를 위해서 V8은 다음과 같이 동작하는 전처리 과정을 가진다.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"배열을 순회하며\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"만약 원소가 hole이다. -\u003e 아무것도 하지 않는다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"만약 원소가 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"이다. -\u003e \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"numberOfUndefineds\"}],\"의 값을 1 증가시킨다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"둘 다 아니라면 원소를 elements라는 임시 배열에 추가한다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"이 작업이 이루어지면, 모든 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"가 아닌 값들은 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"elements\"}],\"라는 임시 배열에 담기게 된다. \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"들은 개수만 알면 된다. 자바스크립트 sort의 명세에 따르면 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\" 들이 맨 끝에 정렬되어야한다. \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\" 값들은 실제로 유저가 제공한 비교 함수에 전달되지 않을 것이기 때문에 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"가 등장한 횟수만 새면 된다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"다음으로 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"elements\"}],\" 배열을 실제로 정렬한다. 글의 후반부 TimSort 섹션에서 자세한 내용을 다룬다.\"]}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"후처리-과정\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"후처리-과정\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#후처리-과정\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"후처리 과정\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"전처리를 거치고 얻은 정렬된 값들을 원본 배열 혹은 객체에 덮어써야 한다. 후처리 과정은 다시 세 단계로 구성된다.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"원본 객체의 앞부터 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"elements\"}],\" 배열로 덮어쓴다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"그 뒤를 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"numberOfUndefineds\"}],\" 값만큼 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"undefined\"}],\"로 채운다.\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"나머지 값들은 삭제한다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"3번 과정은 정렬하려는 원본 객체에 hole이 포함된 경우에 필요하다. 3번을 하지 않으면 배열에 중복된 값이 생길 수 있다.\"}]]}]]}],\"\\n\",[\"$\",\"section\",null,{\"aria-labelledby\":\"과거의-정렬-방식-quicksort\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"mt-8 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"과거의-정렬-방식-quicksort\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#과거의-정렬-방식-quicksort\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"과거의 정렬 방식 (QuickSort)\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"Array.prototype.sort\"}],\" 와 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"TypedArray.prototype.sort\"}],\" 는 자바스크립트로 구현된 Quicksort 구현체에 의존했었다. 정렬 알고리즘 다소 단순하다: 기본적으로는 Quicksort를 하지만, 길이가 짧은 배열(length \u003c 10)에 대해서는 삽입 정렬을 사용한다. Quicksort 재귀 중 하위 배열의 길이가 10에 도달하면 삽입 정렬로 대체된다. 작은 배열에 대해서는 삽입 정렬이 더 효율적인데, 이는 Quicksort가 분할 이후 재귀적으로 두 번 호출되기 때문이다. 각 재귀 호출은 스택 프레임을 생성하고(그리고 제거하는) 오버헤드가 있다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Quicksort에서 적절한 pivot을 선택하는 것은 성능에 큰 영향을 준다. V8은 2가지 전략을 채택했다.\"}],[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"피봇은 정렬될 배열의 첫 번째, 마지막 그리고 third-element 중 중앙값으로 선택되었다. 작은 배열의 경우 third-element는 단순히 배열의 중간 요소로 선정했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"큰 배열에선 표본을 추출하고, 표본을 정렬한 뒤, 정렬된 표본의 중앙값을 위 계산의 third-element로 사용했다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"퀵소트의 이점 중 하나는 in-place 정렬을 한다(혹은 그렇게 구현할 수 있다)는 것이다. 메모리 오버헤드는 큰 배열을 정렬할 때 표본을 저장하기 위한 작은 배열 할당과 log(n)의 스택 영역 할당뿐이다. 단점은 안정정렬이 아니라는 점과 QuickSort는 최악의 상황에 O(n^2)의 성능을 보인다는 점이다. 즉, 안정적이지 않았다.\"}]]}],\"\\n\",[\"$\",\"section\",null,{\"aria-labelledby\":\"현재의-정렬-방식-timsort\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"mt-8 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"현재의-정렬-방식-timsort\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#현재의-정렬-방식-timsort\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"현재의 정렬 방식 (Timsort)\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"2002년 파이썬에 탑재하기 위해 Tim Peter가 개발한 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"Timsort\"}],\"는 Merge sort와 Insertion sort를 기반으로 다양한 최적화 기법을 적용한 정렬이다. 현재는 Python, V8, Swift, Java SE 7 등 다양한 언어에서 채택되었다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"기본적인 아이디어는 다음과 같다.\"}],[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"연속적으로 정렬된 부분을 \\\"run\\\"이라고 하자.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"대부분의 현실 세계 데이터에는 이미 자연적으로 생긴 run들이 포함되어 있다.\\n이 run들을 이용하면 비교와 swap 비용을 줄일 수 있다.\"}],\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 이 run들을 최대한 활용해 보자!\"}],\"\\n\"]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"run이란-무엇인가\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run이란-무엇인가\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run이란-무엇인가\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run이란 무엇인가?\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 배열 내에 자연적으로 발생한 연속 정렬된 부분 수열이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/random_array.jpg\",\"alt\":\"random_array\",\"width\":0,\"height\":0}],[\"$\",\"em\",null,{\"className\":\"[img+\u0026]:block [img+\u0026]:text-center [img+\u0026]:text-gray-400 [img+\u0026]:font-thin [img+\u0026]:not-italic [img+\u0026]:text-sm [img+\u0026]:-translate-y-10\",\"children\":\"랜덤한 배열\"}]]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"위와 같이 10개 원소를 가진 배열이 있다고 하자.\\n\",[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/run_example.jpg\",\"alt\":\"run_example\",\"width\":0,\"height\":0}]]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"위의 배열에서 run을 찾으면 (7,4) (9,3) (8,6,2) (10,1) (5)이 있다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 마지막 원소가 run이 되는 경우를 제외하고는 항상 길이가 2보다 길다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run은 증가하는 경우와 감소하는 경우 둘 다 상관없다. 배열을 증가하도록 정렬할 때 감소하는 run은 단순히 뒤집기만 하면 증가하는 run으로 만들 수 있기 때문이다.\\nrun을 뒤집을 때는 양 끝값을 서로 swap하며 중앙으로 수렴하는 방식을 이용한다. 이때 stable을 지키기 위해 두 값을 비교해 한쪽이 엄격하게 작은 경우에만 swap한다.\"}],[\"$\",\"pre\",null,{\"className\":\"rounded-md [\u0026_code]:py-0 [\u0026_code]:px-0 line-numbers language-js\",\"children\":[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2 language-js\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"funciton \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"reverseRun\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token parameter\",\"children\":\"arr\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"const\"}],\" middle \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token known-class-name class-name\",\"children\":\"Math\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token method function property-access\",\"children\":\"floor\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"/\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"2\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"for\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"let\"}],\" i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\"}],\"middle\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"++\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"if\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"===\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// arr는 어느 방향으로든 정렬이 되어있기 때문에 swap할 두 값의 값이 같다면\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 더 이상 swap을 할 필요가 없다.\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"      \",[\"$\",\"span\",null,{\"className\":\"token keyword control-flow\",\"children\":\"break\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"const\"}],\" temp \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"arr\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token property-access\",\"children\":\"length\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" temp\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"알고리즘-simple\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"알고리즘-simple\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#알고리즘-simple\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"알고리즘 (simple)\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"알고리즘의 순서는 다음과 같다.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"minrun의 길이를 결정한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"배열을 minrun을 기준으로 잘라 run을 만든다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"run을 병합한다. (1개의 배열이 될 때까지 반복한다)\"}],\"\\n\"]}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"minrun의-크기를-결정하는-방식\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"minrun의-크기를-결정하는-방식\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#minrun의-크기를-결정하는-방식\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"minrun의 크기를 결정하는 방식\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run의 크기는 배열의 길이에 따라 유동적으로 결정된다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"배열의 원소 수를 N이라고 하자. minrun이 될 수 있는 최대 값을 MAX_MINRUN이라고 하겠다.\\nN \u003c MAX_MINRUN이라면 minrun값은 N이 된다. 즉, run을 나누지 않는다. 대신 배열을 binary insertion sort한다. 앞서 언급했듯, 작은 배열에선 삽입정렬이 더 효율적이기 때문이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Merge Sort에선 Merge(병합)해야하는 배열의 수가 2의 거듭제곱 (2^x)일때 가장 효율적이다.\\n그럴 수 없다면 2의 거듭제곱보다 조금 적을 때 효과적이다. 가장 최악은 2의 거듭제곱보다 조금 더 많은 경우이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 run의 수가 2의 거듭제곱이 될 수 있게 minrun의 길이를 결정하는 것이 좋다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"예를 들어보자, N=2112, run의 길이는 32라고 하자.\\nrun의 개수는 2112/32 = 66개가 나온다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"66개의 run들을 병합하는 과정을 보자. 각 병합에는 최악의 경우 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"2 * (run의 길이) - 1\"}],\" 번의 비교가 일어난다. 최악의 경우를 따져보자.\"]}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"32길이의 run을 33번 병합해야 한다. 63 * 33번의 비교가 발생했다. (64길이 33개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"64길이의 run을 16번 병합해야 한다. 127 * 16번의 비교가 발생했다. (128길이 16개, 64길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"128길이의 run과 64길이의 run을 병합한다. 128 + 64 - 1번의 비교가 발생했다. (128길이 15개, 192길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"128길이의 run을 7번 병합해야 한다. 255 * 7번의 비교가 발생했다. (256길이 7개, 192길이 1개, 128길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"192길이의 run 1개와 128길이의 run을 병합한다. 192 + 128 - 1번의 비교가 발생했다. (256길이 7개, 320길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"256길이의 run을 3번 병합해야 한다. 511 * 3번의 비교가 발생했다. (512길이 3개, 320길이 1개, 256길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"320길이의 run 1개와 256길이의 run을 병합한다. 320 + 256 - 1번의 비교가 발생했다. (512길이 3개, 576길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"512길이의 run을 1번 병합해야 한다. 1023번의 비교가 발생했다. (1024길이 1개, 576길이 1개, 512길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"576길이의 run 1개와 512길이의 run을 병합한다. 1088번의 비교가 발생했다. (1088길이 1개, 1024길이 1개의 run이 남았다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"1088길이의 run 1개와 1024길이의 run을 병합한다. 2111번의 비교가 발생했다. (병합 완료)\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모두 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"12736\"}],\"번의 비교가 발생한다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"하지만 run의 길이가 33이라면 어떨까?\\nrun의 개수는 2112/33 = 64개가 나온다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"같은 방식으로 병합을 진행해 보자.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"33길이의 run을 32번 병합해야 한다. 65 * 32번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"66길이의 run을 16번 병합해야 한다. 131 * 16번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"132길이의 run을 8번 병합해야 한다. 263 * 8번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"264길이의 run을 4번 병합해야 한다. 527 * 4번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"528길이의 run을 2번 병합해야 한다. 1055 * 2번의 비교가 발생했다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"1056길이의 run을 1번 병합해야 한다. 2111 * 1번의 비교가 발생했다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"모두 \",[\"$\",\"strong\",null,{\"className\":\"font-medium\",\"children\":\"12609\"}],\"번의 비교가 발생한다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"즉, run의 길이가 길어지더라도 run의 개수가 2의 거듭제곱과 일치하면 더 적은 비교가 발생한다.\\nrun의 개수가 2의 거듭제곱보다 조금 많을 때 최악의 경우가 발생한다.\"}],[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run의 개수가 2의 거듭제곱과 같다면 효율적이다.\\nrun의 개수가 2의 거듭제곱보다 조금 클 때 비효율적이다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"따라서 N / minrun이 2의 거듭제곱이 되는 minrun을 선택하고, 그런 minrun을 선택할 수 없다면 2의 거듭제곱에 가깝지만 엄격하게 2의 거듭제곱보다 작아지도록 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"MAX_MINRUN / 2 ~ MAX_MINRUN\"}],\" 사이의 값 중에서 minrun을 선택한다.\\n예를 들어 MAX_MINRUN이 64라면 32 ~ 64중에 minrun을 선택한다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Timsort에선 실제로 MAX_MINRUN을 64로 잡는다. MAX_MINRUN이 8이면 함수 호출이 너무 많아 오버헤드가 더 크고 256이면 binary insertion sort가 느려 마찬가지로 영향을 주는 것을 확인했고, 최종적으로 32를 최적이라 생각했지만, 2112길이의 배열 예시처럼 2의 거듭제곱을 만들 수 있도록 32보다 큰 값을 허용하는 것이 좋다고 판단했기 때문이다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"insertion-sort를-이용하는-이유\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"insertion-sort를-이용하는-이유\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#insertion-sort를-이용하는-이유\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"Insertion sort를 이용하는 이유\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Insertion sort(삽입 정렬)는 언뜻 보면 n^2의 시간복잡도를 가져 느리다고 생각할 수 있다. 하지만 앞서 Quicksort에서 설명했듯, 작은 길이 배열에 대해선 2번의 재귀 호출이 일어나는 Merge Sort보다 참조 지역성 원리의 수혜를 아주 잘 누리는 Insertion sort가 더 효율적이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"특히 배열이 이미 어느 정도 정렬되어 있으면 Insertion Sort는 더욱 효과적으로 된다. Insertion Sort는 최선의 경우 O(n)만큼의 복잡도를 갖기 때문이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"여기에 Binary Insertion sort를 사용하면 원소가 삽입될 위치를 O(nlogn)만에 찾도록 더 최적화할 수 있다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"minrun를-기준으로-run-만들기\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"minrun를-기준으로-run-만들기\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#minrun를-기준으로-run-만들기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"minrun를 기준으로 run 만들기\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"주어진 배열의 길이로부터 minrun을 결정했다. 이제 minrun에 맞춰 배열을 자른다.\\n앞서 minrun은 32~64 사이의 값을 사용한다고 했지만, 이해를 위해 minrun의 값을 4로 잡자.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun1.jpg\",\"alt\":\"find minrun 1\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"먼저 감소하는 부분수열 (7,4)를 찾았다. 하지만 minrun의 길이 4보다 짧기 때문에 뒤의 2개 수를 더 포함해 Binary Insertion Sort를 수행한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun2.jpg\",\"alt\":\"find minrun 2\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이로써 minrun을 만족하는 첫 번째 run을 만들었다.\\n다음 run을 만들어보자.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun3.jpg\",\"alt\":\"find minrun 3\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"마찬가지로 감소하는 길이 3인 부분 수열 (8,6,2)를 찾았다. 마지막 원소를 추가해 Binary Insertion Sort를 수행한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun4.jpg\",\"alt\":\"find minrun 4\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"2번째로 생성한 run은 minrun 길이는 만족했지만, run은 길수록 좋다. 따라서 뒤에 붙은 원소들을 포함해도 감소/증가하는 부분 수열임을 만족한다면 생성한 run에 추가한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"앞선 run에선 (10)을 포함할 수 없었다. 감소하는 run이었기 때문이다.\\n이번 run에선 뒤의 원소 (1)을 붙여도 여전히 감소하는 부분 수열을 만족하기 때문에 (1)을 run에 추가한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun5.jpg\",\"alt\":\"find minrun 5\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"마지막 원소는 합칠 수 있는 원소가 더 이상 없기 때문에 그 자체로 run이 된다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/find_minrun6.jpg\",\"alt\":\"find minrun 6\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이렇게 해서 배열은 마지막 run을 제외하고 minrun과 같거나 더 긴 run들로 구성되었다.\\n이제 이들을 merge하면 된다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"여기서 잠깐, 눈치 챘는지 모르겠지만, TimSort는 일반적인 MergeSort와 달리 재귀가 아닌 반복문을 이용해 구현한다. run을 생성하는 과정은 반복문이 이용된다. 이 덕분에 call stack overflow가 발생하지 않는 점도 최적화 포인트이다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"run을-병합하기\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run을-병합하기\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run을-병합하기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run을 병합하기\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Merge Sort는 병합할 때 비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"길이 m,h인 두 배열을 Merge할 때 최악의 경우 두 배열을 모두 순회하며 비교해야하기 때문에 m+h-1 만큼의 비용이 든다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/merge_compare.jpg\",\"alt\":\"merge compare\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"5개의 원소를 병합하는 과정을 거칠 때를 예로 들어 보자. 앞의 배열부터 순서대로 병합을 진행한다고 하자. 이렇게 되면 큰 배열과 작은 배열을 연속적으로 병합하는 형태가 될 것이다.\\n이때 5개의 원소를 모두 병합하는데 들어가는 비용은 1 + 2 + 3 + 4 = 10이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"반면 작은 길이 배열을 먼저 병합하는 경우 모든 원소를 병합하는 비용은 1 + 1 + 2 + 4 = 8이다.\"}],[\"$\",\"blockquote\",null,{\"className\":\"my-4 border-l-4 border-primary p-6 bg-gray-100 text-gray-700 [\u0026_*:first-child]:mt-0 [\u0026_*:last-child]:mb-0\",\"children\":[\"\\n\",[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"비슷한 길이의 두 배열을 Merge하는 것이 더 효율적이다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 Timsort도 비슷한 길이의 배열을 merge할 수 있도록 다음의 방식으로 run들을 병합한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/merge_criteria.jpg\",\"alt\":\"merge_criteria\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"run을 생성할 때마다 Stack에 추가한다.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"스택의 상위 3개 run을 확인한다. 각각 A, B, C라고 하겠다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"각 run의 길이는 |A|,|B|,|C|라고 하겠다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"다음의 조건을 만족하지 않으면 B를 A와 C 중 짧은 쪽과 병합한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|B|가 |A|보다 길다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|C|가 |A| + |B| 보다 길다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"조건을 만족할 때까지 2를 반복한다.\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이렇게 하면 결과적으로 다음과 같은 Stack을 얻을 수 있다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\",\"alt\":\"fibonacci runstack\",\"width\":0,\"height\":0}]}],[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"A + B \u003c C\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"B + C \u003c D\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"C + D \u003c E\"}],\"\\n\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이 스택은 마치 피보나치의 수처럼 생겼다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이 스택을 위에서부터 순서대로 병합을 하면 비슷한 길이의 run들을 병합할 수 있다.\\n또한 스택에 원소들을 적게 유지할 수 있다. 피보나치의 수를 1부터 38까지 전부 더하면 1억을 좀 넘는 값이 나온다. 즉, 이러한 형태의 스택은 1억 개가 넘는 원소를 스택에 38개의 원소로 담고 있을 수 있다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"run-병합-최적화하기---메모리-최적화\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---메모리-최적화\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---메모리-최적화\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - 메모리 최적화\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"길이가 m,h인 두 run M,H를 병합할 때 우리는 (m+h)*2만큼의 메모리가 필요하다는 것을 알고 있다.\\n하지만 실은 간단한 최적화를 통해 2m + h (m \u003c h)만큼의 메모리를 사용하도록 개선할 수 있다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization.jpg\",\"alt\":\"merge optimization\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"위와 같은 run H와 M이 있다고 하자. (m \u003c h)\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"H 앞에 M을 복사해 붙여 넣는다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization2.jpg\",\"alt\":\"merge optimization 2\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"이제 M의 시작 지점을 i, H의 시작 지점을 j로 두고 각 i와 j를 증가시키며 M의 복사본 + H 배열에 덮어쓰는 식으로 merge를 수행하면 된다.\\ni와 j 이전 인덱스는 확인할 필요가 없기 때문에 이러한 전략이 가능하다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"run-병합-최적화하기---검사할-필요가-없는-지점-찾기\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---검사할-필요가-없는-지점-찾기\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---검사할-필요가-없는-지점-찾기\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - 검사할 필요가 없는 지점 찾기\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/merge_optimization3.jpg\",\"alt\":\"merge optimization 3\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"M의 최댓값(즉 M의 마지막 원소)과 최솟값(M의 첫 번째 원소)가 H안의 어디에 위치하는지 확인하면 그 이후는 병합을 수행하지 않아도 된다.\\n위 이미지에서 M의 최댓값은 6이며 H[3] = 7보다 작다. 따라서 j가 k(=3)위치에 도착했다면 M[i] ~ M[M.length-1]까지의 값과 H[j] ~ H[H.length-1]값은 비교 없이 배열에 추가해 주면 된다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"M의 최댓값, 최솟값이 H 안에서 어디 위치하는지는 Binary Search로 찾으면 된다.\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"run-병합-최적화하기---galloping-모드\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"run-병합-최적화하기---galloping-모드\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#run-병합-최적화하기---galloping-모드\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"run 병합 최적화하기 - Galloping 모드\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"$\",\"$L13\",null,{\"className\":\"object-cover rounded-md mx-auto my-12 w-full max-w-[704px]\",\"src\":\"/next-blog/posts/how-does-v8-array-sort-work/images/galloping1.jpg\",\"alt\":\"galloping1\",\"width\":0,\"height\":0}]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"앞선 예시에서 H를 좀 더 확장해 j와 k 사이에 많은 원소들이 있다고 치자. M[i] 원소를 삽입하기 전까지 H[j]에서부터 6을 발견할 때까지 j와 k 사이를 순회해야한다.\\n\\\"1개씩 모두 순회하지 않고 중간중간을 생략해 보자!\\\"가 Galloping의 아이디어이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"비교할 위치를 2^n씩 건너뛰며 검사한다. 예를 들어 처음 H[1]과 M[1]을 비교했다면 그 다음은 H[2], H[4], H[8]... 형식으로 비교할 index를 증가시킨다.\\n만약 H[8]과 비교해도 M[1]이 더 크다면 H[1] ~ H[8]은 M[1]보다 작은 값이니 H[1] ~ H[8]을 비교없이 merge하면 된다. 만약 M[1]이 H[16]보다 작다면 다시 H[8]로 돌아가 index를 1씩 증가시키며 원소를 비교한다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"Galloping은 꽤 효율적으로 보이지만, Galloping이 비효율적인 구간도 있다.\\n일반적으로 H[0] ~ H[i]까지의 값이 M[0]보다 작을 때 선형적으로 i를 찾게되면 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"i+1\"}],\"번의 비교가 발생하지만, Galloping을 이용하면 \",[\"$\",\"code\",null,{\"className\":\"rounded-md bg-gray-200 text-red-400 py-0.5 px-2\",\"children\":\"2 * floor(log(i)) + 2\"}],\" 번의 비교가 필요하다.\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"따라서 i가 6보다 크거나 같아지는 순간부터 Galloping이 효율적이게 된다. 따라서 선형 비교를 할지 Galloping을 할지 적절한 전략을 세우는 것이 필요하다. (선형비교가 3번 이상 일어나면 Galloping모드로 치환하는 등)\"}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"알고리즘-detail\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"알고리즘-detail\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#알고리즘-detail\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"알고리즘 (detail)\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"다시 알고리즘을 세분화하여 다시 작성해 보자.\"}],[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"minrun을 찾는다. (\",[\"$\",\"$L15\",null,{\"href\":\"https://github.com/python/cpython/blob/main/Objects/listsort.txt\",\"children\":\"listsort.txt\"}],\"의 313줄 참고)\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"배열의 앞부분부터 run을 생성한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"minrun만큼 잘라 binary insertion sort를 수행한다. (처음 두 원소가 증가하는 방향이면 increase 정렬을, 감소하는 방향이면 decrease정렬을 수행한다)\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"그 뒤에 오는 원소들을 run에 합쳐도 증가/감소하는 방향을 유지할 수 있다면 run에 붙인다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":[\"생성한 run을 stack에 추가한다.\",\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"stack의 길이가 3보다 크다면, 스택 상위 3개의 원소(A,B,C)를 다음 조건에 맞는지 확인한다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc my-4\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"|B| \u003e |A|\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"[C| \u003e |A| + |B|\"}],\"\\n\"]}],\"\\n\",[\"$\",\"ol\",null,{\"className\":\"list-decimal my-4\",\"start\":\"2\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"조건에 부합하지 않으면 B를 A와 C중 작은 쪽과 병합(merge)한다. 이를 조건에 부합할 때까지 반복한다.\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"2번으로 돌아가 다음 run을 생성한다.\"}],\"\\n\",[\"$\",\"li\",null,{\"className\":\"text-paragraph font-light leading-normal py-1 ml-6\",\"children\":\"모든 run 생성을 마치고 Stack에 run이 모두 채워졌다면 스택의 맨 위 원소부터 병합을 수행한다.\"}],\"\\n\"]}]]}],[\"$\",\"section\",null,{\"aria-labelledby\":\"timsort의-시간복잡도\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"mt-7 mb-2 text-heading3 font-semibold leading-normal\",\"id\":\"timsort의-시간복잡도\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#timsort의-시간복잡도\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"Timsort의 시간복잡도\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"Insertion Sort의 최선 시간복잡도는 O(n), run을 생성한 결과 run이 1개만 나온 경우 (즉, 이미 정렬된 경우) O(n)의 시간복잡도를 가진다.\\n따라서 Timsort의 최선 시간복잡도는 O(n)이다.\"}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":\"나머지는 사실상 Merge Sort가 진행되는 것과 같기 때문에 최악 시간복잡도와 평균 시간복잡도는 O(nlogn)이다.\"}]]}]]}],\"\\n\",[\"$\",\"section\",null,{\"aria-labelledby\":\"v8의-torque\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"mt-8 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"v8의-torque\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#v8의-torque\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"V8의 Torque\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[\"이 부분은 간단하게만 언급하려고 한다. V8은 Torque라는 V8용 언어를 지원하며, 이 언어를 통해 V8의 JIT 수행에서 미리 컴파일 된 코드를 제공하도록 만들 수 있다.\\nV8은 Torque로 기존 js로 작성된 Array#sort를 다시 작성했으며, 이를 통해 속도를 더욱 끌어올렸다. 구체적인 설명은 \",[\"$\",\"$L15\",null,{\"href\":\"https://v8.dev/blog/array-sort#introducing-v8-torque\",\"children\":\"Introducing V8 Torque\"}],\"를 참고하면 된다.\"]}]]}],\"\\n\",[\"$\",\"section\",null,{\"aria-labelledby\":\"참고\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"mt-8 mb-3 text-heading2 font-semibold leading-normal\",\"id\":\"참고\",\"children\":[[\"$\",\"$L15\",null,{\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"href\":\"#참고\",\"children\":[\"$\",\"span\",null,{\"className\":\"icon icon-link\"}]}],\"참고\"]}],[\"$\",\"p\",null,{\"className\":\"font-light leading-normal mt-4 mb-2\",\"children\":[[\"$\",\"$L15\",null,{\"href\":\"https://v8.dev/blog/array-sort\",\"children\":\"V8 Blog - array-sort\"}],\"\\n\",[\"$\",\"$L15\",null,{\"href\":\"https://en.wikipedia.org/wiki/Timsort\",\"children\":\"위키피디아 - Timsort\"}],\"\\n\",[\"$\",\"$L15\",null,{\"href\":\"https://github.com/python/cpython/blob/main/Objects/listsort.txt\",\"children\":\"cpython - Timsort\"}],\"\\n\",[\"$\",\"$L15\",null,{\"href\":\"https://d2.naver.com/helloworld/0315536\",\"children\":\"D2 - Timsort에 대해 알아보자\"}]]}]]}]],[\"$\",\"$L16\",null,{\"size\":\"lg\",\"shareData\":{\"title\":\"Terra Dev Blog - V8의 `Array.sort`는 어떻게 동작하는가?\",\"text\":\"$undefined\",\"url\":\"/next-blog/posts/how-does-v8-array-sort-work\"},\"aria-label\":\"Share this article\"}]]}],[\"$\",\"section\",null,{\"id\":\"author\",\"children\":[\"$\",\"$L17\",null,{}]}],[\"$\",\"section\",null,{\"id\":\"comments-and-reaction\",\"children\":[[\"$\",\"$Lb\",null,{\"src\":\"https://giscus.app/client.js\",\"data-repo\":\"dev2820/blog-posts\",\"data-repo-id\":\"R_kgDOLQagPA\",\"data-category\":\"General\",\"data-category-id\":\"DIC_kwDOLQagPM4CjAtl\",\"data-mapping\":\"og:title\",\"data-strict\":\"0\",\"data-reactions-enabled\":\"1\",\"data-emit-metadata\":\"0\",\"data-input-position\":\"top\",\"data-theme\":\"light\",\"data-lang\":\"ko\",\"data-loading\":\"lazy\",\"cross-origin\":\"anonymous\",\"async\":true}],[\"$\",\"div\",null,{\"className\":\"giscus w-full\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Terra Dev Blog - V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"link\",\"3\",{\"rel\":\"canonical\",\"href\":\"https://dev2820.github.io/next-blog/how-does-v8-array-sort-work\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:url\",\"content\":\"https://dev2820.github.io/next-blog/how-does-v8-array-sort-work\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://dev2820.github.io/next-blog/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:height\",\"content\":\"600\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:alt\",\"content\":\"V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:image\",\"content\":\"https://dev2820.github.io/next-blog/next-blog/posts/how-does-v8-array-sort-work/images/fibonacci.jpg\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:image:height\",\"content\":\"600\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:image:alt\",\"content\":\"V8의 `Array.sort`는 어떻게 동작하는가?\"}],[\"$\",\"link\",\"18\",{\"rel\":\"icon\",\"href\":\"/next-blog/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"19\",{\"name\":\"next-size-adjust\"}]]\n6:null\n"])</script></body></html>